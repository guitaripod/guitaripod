name: Update Recent Releases

on:
  release:
    types: [published]
  schedule:
    - cron: '0 * * * *'  # Runs at minute 0 of every hour
  workflow_dispatch:

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Fetch Recent Releases
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            // Function to extract release data from HTML section
            function extractReleaseData(section) {
              const releases = [];
              const rows = section.match(/<tr>[\s\S]*?<\/tr>/g) || [];
              
              for (const row of rows) {
                // Skip header row
                if (row.includes('<th>')) continue;
                
                // Extract key data points that would indicate a change
                const repo = row.match(/href="([^"]+)">([^<]+)<\/a>/);
                const version = row.match(/<td>([^<]+)<\/td>/g)?.[2]?.replace(/<\/?td>/g, '');
                const date = row.match(/<td>([^<]+)<\/td>/g)?.[3]?.replace(/<\/?td>/g, '');
                const stars = row.match(/‚≠ê\s*([0-9]+)/)?.[1];
                
                if (repo && version && date) {
                  releases.push({
                    repo: repo[2],
                    version: version.trim(),
                    date: date.trim(),
                    stars: stars ? parseInt(stars) : 0
                  });
                }
              }
              return releases;
            }

            // Function to compare two release arrays
            function releasesAreDifferent(oldReleases, newReleases) {
              if (oldReleases.length !== newReleases.length) return true;
              
              for (let i = 0; i < oldReleases.length; i++) {
                const old = oldReleases[i];
                const newR = newReleases[i];
                
                if (old.repo !== newR.repo ||
                    old.version !== newR.version ||
                    old.date !== newR.date ||
                    old.stars !== newR.stars) {
                  return true;
                }
              }
              
              return false;
            }
            
            // Read current README first
            console.log('Reading README...');
            let readme = fs.readFileSync('README.md', 'utf8');
            
            // Extract current releases section if it exists
            let originalSection = '';
            let currentReleases = [];
            if (readme.includes('<!-- Recent Releases -->')) {
              const start = readme.indexOf('<!-- Recent Releases -->');
              const end = readme.indexOf('<!-- End Recent Releases -->') + '<!-- End Recent Releases -->'.length;
              originalSection = readme.substring(start, end);
              currentReleases = extractReleaseData(originalSection);
            }
            
            console.log('Fetching repositories...');
            const repos = await github.rest.repos.listForUser({
              username: context.repo.owner,
              per_page: 100,
              sort: 'updated'
            });
            
            // Create a map to store latest release per repo
            let repoReleasesMap = new Map();
            
            // Fetch releases and additional repo data
            for (const repo of repos.data) {
              try {
                const [releases, repoDetails] = await Promise.all([
                  github.rest.repos.listReleases({
                    owner: context.repo.owner,
                    repo: repo.name,
                    per_page: 1
                  }),
                  github.rest.repos.get({
                    owner: context.repo.owner,
                    repo: repo.name
                  })
                ]);
                
                if (releases.data.length > 0) {
                  const release = releases.data[0];
                  release.repo_name = repo.name;
                  release.language = repo.language;
                  release.stars = repoDetails.data.stargazers_count;
                  release.description = repoDetails.data.description;
                  repoReleasesMap.set(repo.name, release);
                }
              } catch (error) {
                console.log(`Error fetching data for ${repo.name}: ${error.message}`);
              }
            }
            
            // Convert map to array and sort by date
            let allReleases = Array.from(repoReleasesMap.values());
            allReleases.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));
            allReleases = allReleases.slice(0, 5);
            
            function formatDate(dateStr) {
              const date = new Date(dateStr);
              return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
              });
            }
            
            // Prepare new section
            let newSection;
            let newReleasesData = [];
            
            if (allReleases.length === 0) {
              newSection = [
                '\n<!-- Recent Releases -->',
                '<div style="width: 80%; text-align: right;">',
                '<h3>üì¶ Latest Releases</h3>',
                '<p>No releases yet</p>',
                '</div>',
                '<!-- End Recent Releases -->'
              ].join('\n');
            } else {
              // Transform the new releases into comparable format
              newReleasesData = allReleases.map(release => ({
                repo: release.repo_name,
                version: release.name || release.tag_name,
                date: formatDate(release.published_at),
                stars: release.stars
              }));
              
              const tableRows = allReleases.map(release => {
                const name = release.name || release.tag_name;
                const date = formatDate(release.published_at);
                return `<tr>
                  <td>${release.language || 'N/A'}</td>
                  <td><a href="${release.html_url}">${release.repo_name}</a></td>
                  <td>${name}</td>
                  <td>${date}</td>
                  <td>‚≠ê ${release.stars}</td>
                  <td>${release.description || ''}</td>
                </tr>`;
              }).join('\n');

              newSection = [
                '\n<!-- Recent Releases -->',
                '<div style="width: 80%; text-align: right;">',
                '<h3>üì¶ Latest Releases</h3>',
                '<table style="margin-left: auto;">',
                '<thead>',
                '<tr>',
                '<th>Lang</th>',
                '<th>Repository</th>',
                '<th>Version</th>',
                '<th>Released</th>',
                '<th>Stars</th>',
                '<th>Description</th>',
                '</tr>',
                '</thead>',
                '<tbody>',
                tableRows,
                '</tbody>',
                '</table>',
                '</div>',
                '<!-- End Recent Releases -->\n'
              ].join('\n');
            }
            
            // Compare the actual release data instead of HTML content
            if (releasesAreDifferent(currentReleases, newReleasesData)) {
              console.log('Changes detected in release data, updating README...');
              // Update or append the section
              if (originalSection) {
                readme = readme.replace(originalSection, newSection);
              } else {
                const insertPoint = readme.indexOf('![Profile views]');
                if (insertPoint !== -1) {
                  readme = readme.slice(0, insertPoint) + newSection + readme.slice(insertPoint);
                } else {
                  readme += newSection;
                }
              }
              
              fs.writeFileSync('README.md', readme);
              // Create a file to signal that changes were made
              fs.writeFileSync('changes_detected', 'true');
            } else {
              console.log('No changes detected in release data');
            }

      - name: Commit and Push if Changed
        run: |
          if [ -f changes_detected ]; then
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add README.md
            git commit -m "Update recent releases section"
            git push
            rm changes_detected
          else
            echo "No changes to commit"
          fi